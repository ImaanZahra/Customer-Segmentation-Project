# -*- coding: utf-8 -*-
"""Customer Segmentation Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11ylYiyMPrsrHF6Qt2Gkq5oTT05ZSirfI
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA

df=pd.read_excel('/content/Online Retail.xlsx')

print(df.head().to_markdown(index=False, numalign="left", stralign="left"))
print(df.info())

descriptive_stats = df.describe()
print("Descriptive Statistics")
print(descriptive_stats.to_markdown(numalign="left", stralign="left"))

data_full = df.dropna(subset=['CustomerID'])
data_full = df[(df['Quantity'] > 0) & (df['UnitPrice'] > 0)]
data_full.info()

"""**Feature Engineering**"""

# Calculate TotalPrice (Monetary value) for each transaction
data_full.loc[:, 'TotalPrice'] = data_full['Quantity'] * data_full['UnitPrice']

# Convert 'InvoiceDate' to datetime
data_full.loc[:, 'InvoiceDate'] = pd.to_datetime(data_full['InvoiceDate'])

# Group by CustomerID to get aggregated RFM metrics
customer_metrics = data_full.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (data_full['InvoiceDate'].max() - x.max()).days,  # Recency
    'InvoiceNo': 'nunique',  # Frequency
    'TotalPrice': 'sum'  # Monetary value
})

# Rename columns to Recency, Frequency, and Monetary
customer_metrics.columns = ['Recency', 'Frequency', 'Monetary']

# Display the first five rows to check the RFM metrics
print(customer_metrics.head())

"""**Clustering with K-means**"""

# Scaling the RFM data
scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(customer_metrics)

# Determine optimal number of clusters using the Elbow method
inertia = []
for k in range(1, 10):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(rfm_scaled)
    inertia.append(kmeans.inertia_)

# Plot Elbow curve to find optimal clusters
plt.figure(figsize=(8, 6))
plt.plot(range(1, 10), inertia, marker='o')
plt.title('Elbow Method for Optimal K')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()

# Fit K-Means with optimal number of clusters (e.g., 4)
kmeans = KMeans(n_clusters=4, random_state=42)
customer_metrics['Cluster'] = kmeans.fit_predict(rfm_scaled)

# Plot the number of customers in each cluster
plt.figure(figsize=(8, 6))
sns.countplot(x='Cluster', data=customer_metrics, palette='viridis')
plt.title('Customer Count in Each Cluster')
plt.show()

# Analyze the average RFM values for each cluster
cluster_summary = customer_metrics.groupby('Cluster').mean()
print(cluster_summary)

print(f'Final inertia: {kmeans.inertia_}')

score = silhouette_score(rfm_scaled, customer_metrics['Cluster'])
print(f'Silhouette Score: {score}')

# Set the figure size
plt.figure(figsize=(15, 5))

# Plot Recency
plt.subplot(1, 3, 1)
sns.boxplot(x='Cluster', y='Recency', data=customer_metrics)
plt.title('Recency by Cluster')

# Plot Frequency
plt.subplot(1, 3, 2)
sns.boxplot(x='Cluster', y='Frequency', data=customer_metrics)
plt.title('Frequency by Cluster')

# Plot Monetary
plt.subplot(1, 3, 3)
sns.boxplot(x='Cluster', y='Monetary', data=customer_metrics)
plt.title('Monetary by Cluster')

plt.tight_layout()
plt.show()

